//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////// GAMEWORLD.CC /////////////////////////////////////
///////////////////////////////////////////jrs38//////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////

#include "GameWorld.h"
#include "common.h"
using namespace std;

GameWorld::GameWorld (ApplicationMode mode) : asset_manager (make_shared<GameAssetManager>(mode)){
  
  int X,Y;
  int Z = 0;
  int worldX = 11;
  int worldY = 11;

//////////////////////////////////////////////////////////////////////////////////////////
//Voxel Array ////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
  int world[worldX][worldY] = {
    { 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1 } ,
    { 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0 } ,
    { 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1 } ,
    { 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0 } ,
    { 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0 } ,
    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } ,
    { 0, 2, 2, 2, 0, 2, 0, 2, 0, 0, 0 } ,
    { 0, 0, 2, 0, 0, 2, 0, 2, 0, 0, 0 } ,
    { 0, 0, 2, 0, 0, 2, 0, 2, 0, 0, 0 } ,
    { 0, 0, 2, 0, 0, 2, 0, 2, 2, 0, 0 } ,
    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
  };

//////////////////////////////////////////////////////////////////////////////////////////
//Adding Assets To The Scene /////////////////////////////////////////////////////////////
//1 = Square                                                                            //
//2 = Pyramid (Worked on by Lauren)                                     //
//////////////////////////////////////////////////////////////////////////////////////////
 for( X=0; X<worldX; X++){
   for (Y=0; Y<worldY; Y++){
    if( world[Y][X] == 1){  
      asset_manager->AddAsset(std::make_shared<CubeAsset>(glm::vec3(X, 0, Y), 2, 1, glm::vec3(0.0,0.0,0.0), glm::vec3(0.0,0.0,0.0)));
      asset_manager->AddAsset(make_shared<CubeAsset>(glm::vec3(X, 3, Y), 1, 1, glm::vec3(0.0,0.0,0.0), glm::vec3(0.0,0.0,0.0)));
      asset_manager->AddAsset(make_shared<CubeAsset>(glm::vec3(X, 6, Y), 3, 1, glm::vec3(0.0,0.0,0.0), glm::vec3(0.0,0.0,0.0)));
    }
     else if (world[Y][X] == 2){ 
	  asset_manager->AddAsset(std::make_shared<PyramidAsset>(glm::vec3(X, 5, Y), 2, 1, glm::vec3(0.0,0.0,0.0), glm::vec3(0.0,0.0,0.0)));
    }
   }
 }
}

//////////////////////////////////////////////////////////////////////////////////////////
//Draws The Game World ///////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
void GameWorld::Draw() {
  asset_manager->Draw();
}

//////////////////////////////////////////////////////////////////////////////////////////
//Updates The Position Of The Camera /////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
void GameWorld::UpdateCameraPosition(Input input_direction, int mouseX, int mouseY){
  asset_manager->UpdateCameraPosition(input_direction,  mouseX,  mouseY);
}
